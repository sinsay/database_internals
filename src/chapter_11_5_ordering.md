# Ordering

在我们看到一系列的事件时，对这些事件的执行顺序会产生直觉上的了解，但这在分布式系统中却并非那么容易，因为很难去确定在整个集群在某个时刻具体发生的事情及其当时的状态。每个参与者可能都会对这个状态有自己的看法，因此我们需要去观察所有的操作跟定义其对应的任期，来描述操作执行跟完成事件的边界信息。

接着来定义一个能够在共享的寄存器上执行 `read(register)` 操作跟 `write(register, value)` 操作的系统。每个处理器都会顺序的执行他自己的操作集合 *(比如执行的操作完成后才能开始下一个操作)* 。这些顺序执行的操作的组合形成了全局的执行历史，其中更包含了可以并行执行的操作。

最简单的关于一致性模型的思考是读取跟写入的操作是允许重叠的：写入操作对寄存器状态产生的变更对读取的操作不会产生副作用。这能够帮助我们去解释，数据在写入之后的什么时候是可读的。比如，考虑下面这两个处理器并行处理的处理器历史：

```
Process 1:     Process 2:
write(x, 1)    read(x)
               read(x)
```

在观察这些事件时，对于 `read(x)`操作的返回结果是很不明确的，我们有下面几种可能的历史状态：

- 写入在两个读取操作之前完成
- 写入跟两个读取之间可能会错开，也可能会在两个读取操作中间进行
- 所有的读取都在写入之前完成

在我们只有一份数据拷贝的情况下很难简单的去回答具体发生了什么。在使用了复制的系统中，我们有更多的可能的状态组合，他可能会在同时有多个处理器读取跟写入数据时带来更复杂的情况。

如果所有的这些操作都是在同一个处理器上执行的，我们可以强制指定事件的顺序，但在多处理器中很难去实现这点。我们可以将隐含的困难分成两种：

- 操作可能会重叠
- 不重叠的调用之间的影响不会马上显现

为了对操作的顺序以及可能产生的结果进行解释，我们需要定义一致性模型。在分布式系统中我们还是使用共享内存跟并发系统来说明并发，因为相关的规则仍然是适用的。尽管在并发跟分布式系统中的术语有一些重叠的情况，我们却没办法直接的将大部分的并发算法应用到分布式系统，因为他们之间具有不同的通信模式、性能跟可靠性。